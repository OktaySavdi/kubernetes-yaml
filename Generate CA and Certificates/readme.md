# Introduction

A Kubernetes cluster has several components. Each of these components communicate to each other and outside world with with encrypted channels. It is possible to use a single certificate for all of the components. However, being more straight-forward to do so is not recommended. In this study individual certificates will be used for each components. Additional information regards to Transport Layer Security (TLS) and Public Key Infrastructure (PKI) can be found [here](https://en.wikipedia.org/wiki/Public_key_infrastructure).

# Certificate Authority

A Certificate Authority (CA) will be generated by using `OpenSSL`. Generated CA will then be used to generate additional certificates which will be used in individual components of the Kubernetes cluster. A CA certificate will be generated, then a Certificate Signing Request (CSR). By using the CSR a private key will be created.

```bash
$ mkdir k8s.certs; cd k8s.certs
$ openssl version          
OpenSSL 1.1.1f  31 Mar 2020
$ tee -a create.ca.sh <<EOF
#!/bin/bash
# Private key
openssl genrsa -out ca.key 2048
# CSR
openssl req -new -key ca.key -subj "/CN=Kubernetes/O=Kubernetes" -out ca.csr
# Sign the CSR
openssl x509 -req -in ca.csr -signkey ca.key -CAcreateserial  -out ca.crt -days 3650
EOF
$ chmod +x create.ca.sh
$ ./create.ca.sh  
$ ls ca*
ca.crt  ca.csr  ca.key

```

# Admin Client Certificate

Admin client certificate is used by Kubernetes `admin` user.

```bash
$ tee -a create.admin.certs.sh <<EOF
#!/bin/bash
# Private key
openssl genrsa -out admin.key 2048
# CSR
openssl req -new -key admin.key -subj "/CN=admin/O=system:masters" -out admin.csr
# Sign the certificate
openssl x509 -req -in admin.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial  -out admin.crt -days 3650
EOF
$ chmod +x create.admin.certs.sh 
$ ./create.admin.certs.sh 
$ ls admin*
admin.crt admin.csr admin.key

```

By setting its `Organization` to system:masters, admin user is enabled to perform administrative tasks. `kubectl` command line utility will be configured with this certificate/key pair to manage the kubernetes cluster.

# Kubelet Client Certificates

Kubelet client certificate is used in worker nodes to authorize the requests being sent to Kubernetes Control Plane.

```bash

$ for node in 1 2 3; do
tee -a openssl-worker-${node}.cnf <<EOF
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alt_names
[alt_names]
DNS.1 = worker-${node}.$STUDENT_NAME.8-mega.local
IP.1 = 192.168.$STUDENT_ID.2${node}
IP.3 = $K8S_PUBLIC_IP
EOF
done
$ tee -a create.kubelet.client.certs.sh <<EOF
#!/bin/bash
#
EOF
$ for node in 1 2 3; do
tee -a create.kubelet.client.certs.sh <<EOF
#===== worker-${node}.$STUDENT_NAME.8-mega.local
#
# Private key
openssl genrsa -out worker-${node}.$STUDENT_NAME.8-mega.local.key 2048
# CSR
openssl req -new -key worker-${node}.$STUDENT_NAME.8-mega.local.key -subj "/CN=system:node:worker-${node}.$STUDENT_NAME.8-mega.local/O=system:nodes" -out worker-${node}.$STUDENT_NAME.8-mega.local.csr -config openssl-worker-${node}.cnf
# Sign the CSR
openssl x509 -req -in worker-${node}.$STUDENT_NAME.8-mega.local.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial  -out worker-${node}.$STUDENT_NAME.8-mega.local.crt -extensions v3_req -extfile openssl-worker-${node}.cnf -days 3650
EOF
done
$ chmod +x create.kubelet.client.certs.sh 
$ ./create.kubelet.client.certs.sh 
t$ ls *worker*
openssl-worker-1.cnf openssl-worker-3.cnf openssl-worker-2.cnf
worker-1.prime.8-mega.local.key worker-1.prime.8-mega.local.csr worker-1.prime.8-mega.local.crt
worker-2.prime.8-mega.local.key worker-2.prime.8-mega.local.csr worker-2.prime.8-mega.local.crt
worker-3.prime.8-mega.local.key worker-3.prime.8-mega.local.csr worker-3.prime.8-mega.local.crt

```

The requests made by Kubelets need to be authorized by [Node Authorizer](https://kubernetes.io/docs/reference/access-authn-authz/node/). To get the authorizations Kubelets must have a credential from `system:nodes` group with the username format `system:node:<node_name>`. Hence the CN field of kubelet client certificates has been set accordingly.

# Kube Controller Manager Client Certificate

The `kube-controller-manager` client certificate is generated.

```bash
$ tee -a create.kube-controller-manager.certs.sh <<EOF
#!/bin/bash
# Private key
openssl genrsa -out kube-controller-manager.key 2048
# CSR
openssl req -new -key kube-controller-manager.key -subj "/CN=system:kube-controller-manager/O=system:kube-controller-manager" -out kube-controller-manager.csr
# Sign the CSR
openssl x509 -req -in kube-controller-manager.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial  -out kube-controller-manager.crt -extensions v3_req -days 3650
EOF
$ chmod +x create.kube-controller-manager.certs.sh 
$ ./create.kube-controller-manager.certs.sh 
$ ls *kube-controller-manager*
create.kube-controller-manager.certs.sh
kube-controller-manager.key kube-controller-manager.csr kube-controller-manager.crt

```

# Kube Proxy Client Certificate

The `kube-proxy` client certificate is generated.

```bash
$ tee -a create.kube-proxy.certs.sh <<EOF
#!/bin/bash
# Private key
openssl genrsa -out kube-proxy.key 2048
# CSR
openssl req -new -key kube-proxy.key -subj "/CN=system:kube-proxy/O=system:kube-proxy" -out kube-proxy.csr
# Sign the CSR
openssl x509 -req -in kube-proxy.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial  -out kube-proxy.crt -extensions v3_req -days 3650
EOF
$ chmod +x create.kube-proxy.certs.sh 
$ ./create.kube-proxy.certs.sh 
$ ls -ltr *kube-proxy*
create.kube-proxy.certs.sh
kube-proxy.key kube-proxy.csr kube-proxy.crt

```

# Kube Scheduler Client Certificate

The `kube-scheduler` client certificate is generated.

```bash
$ tee -a create.kube-scheduler.certs.sh <<EOF
#!/bin/bash
# Private key
openssl genrsa -out kube-scheduler.key 2048
# CSR
openssl req -new -key kube-scheduler.key -subj "/CN=system:kube-scheduler/O=system:kube-scheduler" -out kube-scheduler.csr
# Sign the CSR
openssl x509 -req -in kube-scheduler.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial  -out kube-scheduler.crt -extensions v3_req -days 3650
EOF
$ chmod +x create.kube-scheduler.certs.sh 
$ ./create.kube-scheduler.certs.sh 
$ ls *kube-scheduler*
create.kube-scheduler.certs.sh
kube-scheduler.key kube-scheduler.csr kube-scheduler.crt

```

# Kubernetes API Server Certificate

Names or IP address of all components (DNS Names, Master Node IP addresses, Kubernetes Public IP address, kube-apiserver service IP address) that might reach to `kube-apiserver` must be part of its certificate. In the above example 10.32.0.1 is kube-apiserver service IP address. 10.32.0.0/24 will be used for internal service subnet. The first IP of this subnet is automatically reserved for DNS name `kubernetes`.

```bash
$ tee -a openssl-kube-api-server.cnf <<EOF
[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alt_names
[alt_names]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster
DNS.5 = kubernetes.default.svc.cluster.local
IP.1 = $K8S_PUBLIC_IP
IP.2 = 192.168.2.11
IP.3 = 192.168.2.12
IP.4 = 192.168.2.13
IP.5 = 127.0.0.1
IP.6 = 10.32.0.1
EOF
$ tee -a create.kube-api-server.certs.sh <<EOF
#!/bin/bash
 Private key
openssl genrsa -out kube-api-server.key 2048
# CSR
openssl req -new -key kube-api-server.key -subj "/CN=kubernetes/O=kubernetes" -out kube-api-server.csr -config openssl-kube-api-server.cnf
# Sign the CSR
openssl x509 -req -in kube-api-server.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial  -out kube-api-server.crt -extensions v3_req -extfile openssl-kube-api-server.cnf -days 3650
EOF
$ chmod +x create.kube-api-server.certs.sh 
$ ./create.kube-api-server.certs.sh 
$ ls *kube-api-server*
openssl-kube-api-server.cnf create.kube-api-server.certs.sh
kube-api-server.key kube-api-server.csr kube-api-server.crt

```

# Service Account Key Pair

The Kubernetes Controller Manager leverages a key pair to generate and sign service account tokens as describe in the [managing service accounts](https://kubernetes.io/docs/admin/service-accounts-admin/) documentation.

```bash
$ tee -a create.service-account.certs.sh <<EOF
#!/bin/bash
# Private key
openssl genrsa -out service-account.key 2048
# CSR
openssl req -new -key service-account.key -subj "/CN=service-accounts" -out service-account.csr
# Sign the CSR
openssl x509 -req -in service-account.csr -CA ./ca.crt -CAkey ./ca.key -CAcreateserial  -out service-account.crt -days 3650
EOF
$ chmod  +x create.service-account.certs.sh 
$ ./create.service-account.certs.sh 
$ ls *service-account* 
create.service-account.certs.sh
service-account.key service-account.csr service-account.crt

```

# Distribute Certificates

Distribute the generated certificates with respect to below table


![Ekran Resmi 2022-01-05 18 50 25](https://user-images.githubusercontent.com/3519706/148247230-45b726d7-2507-41af-8553-f3efa70fb8eb.png)


Reference : [URL](https://8-mega.notion.site/Generate-CA-and-Certificates-9aebed7c314f4c5498fe215feca4e5f2)
